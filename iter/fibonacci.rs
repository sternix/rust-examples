fn main() {
    // dikkat edilirse mut olarak alıyor
    // the iterator method take() is an adapter which limits the number of items
    // generated by the original iterator
    // eğer take kullanmazsak sonsuza kadar gider
    for i in Fibonacci(0, 1).take(100) {
        println!("{}", i);
    }
}

struct Fibonacci(u64, u64);

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        let ret = self.0;
        self.0 = self.1;
        self.1 += ret;

        // since None is never returned, we have an infinite iterator
        // None dönmediği için sonsuz döngü
        // debug'ta panic (attempt to add with overflow) fakat release'de başa dönüyor
        Some(ret)
    }

    // Implementing the next() method suffices since every other iterator
    // method has a default implementation
}
